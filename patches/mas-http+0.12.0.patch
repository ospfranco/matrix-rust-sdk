diff --git a/Cargo.toml b/Cargo.toml
index 05dd02d..ee6782f 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,28 +1,30 @@
 [package]
 name = "mas-http"
 description = "HTTP utilities for the Matrix Authentication Service"
-version.workspace = true
-authors.workspace = true
-edition.workspace = true
-license.workspace = true
-homepage.workspace = true
-repository.workspace = true
-
-[lints]
-workspace = true
+version = "0.12.0"
+# authors.workspace = true
+edition = "2021"
+# license.workspace = true
+# homepage.workspace = true
+# repository.workspace = true
 
 [dependencies]
-futures-util.workspace = true
-headers.workspace = true
-http.workspace = true
-hyper-util.workspace = true
-opentelemetry-http.workspace = true
-opentelemetry-semantic-conventions.workspace = true
-opentelemetry.workspace = true
-reqwest.workspace = true
-rustls-platform-verifier.workspace = true
-tokio.workspace = true
-tower.workspace = true
-tower-http.workspace = true
-tracing.workspace = true
-tracing-opentelemetry.workspace = true
+futures-util = "0.3.31"
+headers = "0.4.0"
+http = "1.2.0"
+hyper-util = { version = "0.1.10", features = ["client", "http1", "http2"]}
+# opentelemetry-http = {version = "0.27.0", features = ["reqwest"]}
+# opentelemetry-semantic-conventions = {version = "0.27.0", features = ["semconv_experimental"]}
+# opentelemetry = {version = "0.27.1", features = ["trace", "metrics"]}
+reqwest = { version = "0.12.12", default-features = false, features = ["json", "socks"]}
+# rustls-platform-verifier = "0.3.4"
+tower = {version = "0.5.2", features = ["util"]}
+tower-http = {version = "0.6.2", features = ["cors", "add-extension", "set-header"]}
+# tracing = "0.1.41"
+# tracing-opentelemetry = {version = "0.28.0", default-features = false}
+
+# [target.'cfg(target_arch = "wasm32")'.dependencies]
+web-time = { version = "1.1.0" }
+
+# [target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+# tokio.workspace = true
\ No newline at end of file
diff --git a/src/ext.rs b/src/ext.rs
index 838531d..2dab52f 100644
--- a/src/ext.rs
+++ b/src/ext.rs
@@ -17,20 +17,17 @@ static PROPAGATOR_HEADERS: OnceLock<Vec<HeaderName>> = OnceLock::new();
 /// # Panics
 ///
 /// When called twice
-pub fn set_propagator(propagator: &dyn opentelemetry::propagation::TextMapPropagator) {
-    let headers = propagator
-        .fields()
-        .map(|h| HeaderName::try_from(h).unwrap())
-        .collect();
+// pub fn set_propagator(propagator: &dyn opentelemetry::propagation::TextMapPropagator) {
+// let headers = propagator.fields().map(|h| HeaderName::try_from(h).unwrap()).collect();
 
-    tracing::debug!(
-        ?headers,
-        "Headers allowed in CORS requests for trace propagators set"
-    );
-    PROPAGATOR_HEADERS
-        .set(headers)
-        .expect(concat!(module_path!(), "::set_propagator was called twice"));
-}
+// tracing::debug!(
+//     ?headers,
+//     "Headers allowed in CORS requests for trace propagators set"
+// );
+//     PROPAGATOR_HEADERS
+//         .set(headers)
+//         .expect(concat!(module_path!(), "::set_propagator was called twice"));
+// }
 
 pub trait CorsLayerExt {
     #[must_use]
diff --git a/src/lib.rs b/src/lib.rs
index be631ff..66924e7 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -15,15 +15,15 @@ mod ext;
 mod reqwest;
 
 pub use self::{
-    ext::{set_propagator, CorsLayerExt},
+    // ext::{set_propagator, CorsLayerExt},
     reqwest::{client as reqwest_client, RequestBuilderExt},
 };
 
-static METER: LazyLock<opentelemetry::metrics::Meter> = LazyLock::new(|| {
-    let scope = opentelemetry::InstrumentationScope::builder(env!("CARGO_PKG_NAME"))
-        .with_version(env!("CARGO_PKG_VERSION"))
-        .with_schema_url(opentelemetry_semantic_conventions::SCHEMA_URL)
-        .build();
+// static METER: LazyLock<opentelemetry::metrics::Meter> = LazyLock::new(|| {
+//     let scope = opentelemetry::InstrumentationScope::builder(env!("CARGO_PKG_NAME"))
+//         .with_version(env!("CARGO_PKG_VERSION"))
+//         .with_schema_url(opentelemetry_semantic_conventions::SCHEMA_URL)
+//         .build();
 
-    opentelemetry::global::meter_with_scope(scope)
-});
+//     opentelemetry::global::meter_with_scope(scope)
+// });
diff --git a/src/reqwest.rs b/src/reqwest.rs
index b895338..ebf4bd6 100644
--- a/src/reqwest.rs
+++ b/src/reqwest.rs
@@ -12,76 +12,79 @@ use std::{
 
 use futures_util::FutureExt as _;
 use headers::{ContentLength, HeaderMapExt as _, UserAgent};
-use hyper_util::client::legacy::connect::{
-    dns::{GaiResolver, Name},
-    HttpInfo,
-};
-use opentelemetry::{
-    metrics::{Histogram, UpDownCounter},
-    KeyValue,
-};
-use opentelemetry_http::HeaderInjector;
-use opentelemetry_semantic_conventions::{
-    attribute::{HTTP_REQUEST_BODY_SIZE, HTTP_RESPONSE_BODY_SIZE},
-    metric::{HTTP_CLIENT_ACTIVE_REQUESTS, HTTP_CLIENT_REQUEST_DURATION},
-    trace::{
-        ERROR_TYPE, HTTP_REQUEST_METHOD, HTTP_RESPONSE_STATUS_CODE, NETWORK_LOCAL_ADDRESS,
-        NETWORK_LOCAL_PORT, NETWORK_PEER_ADDRESS, NETWORK_PEER_PORT, NETWORK_TRANSPORT,
-        NETWORK_TYPE, SERVER_ADDRESS, SERVER_PORT, URL_FULL, URL_SCHEME, USER_AGENT_ORIGINAL,
-    },
-};
+// use hyper_util::client::legacy::connect::{
+//     dns::{GaiResolver, Name},
+//     HttpInfo,
+// };
+// use opentelemetry::{
+//     metrics::{Histogram, UpDownCounter},
+//     KeyValue,
+// };
+// use opentelemetry_http::HeaderInjector;
+// use opentelemetry_semantic_conventions::{
+//     attribute::{HTTP_REQUEST_BODY_SIZE, HTTP_RESPONSE_BODY_SIZE},
+//     metric::{HTTP_CLIENT_ACTIVE_REQUESTS, HTTP_CLIENT_REQUEST_DURATION},
+//     trace::{
+//         ERROR_TYPE, HTTP_REQUEST_METHOD, HTTP_RESPONSE_STATUS_CODE, NETWORK_LOCAL_ADDRESS,
+//         NETWORK_LOCAL_PORT, NETWORK_PEER_ADDRESS, NETWORK_PEER_PORT, NETWORK_TRANSPORT,
+//         NETWORK_TYPE, SERVER_ADDRESS, SERVER_PORT, URL_FULL, URL_SCHEME, USER_AGENT_ORIGINAL,
+//     },
+// };
+#[cfg(not(target_arch = "wasm32"))]
 use tokio::time::Instant;
 use tower::{BoxError, Service as _};
-use tracing::Instrument;
-use tracing_opentelemetry::OpenTelemetrySpanExt;
+// use tracing::Instrument;
+// use tracing_opentelemetry::OpenTelemetrySpanExt;
+#[cfg(target_arch = "wasm32")]
+use web_time::Instant;
 
-use crate::METER;
+// use crate::METER;
 
 static USER_AGENT: &str = concat!("matrix-authentication-service/", env!("CARGO_PKG_VERSION"));
 
-static HTTP_REQUESTS_DURATION_HISTOGRAM: LazyLock<Histogram<u64>> = LazyLock::new(|| {
-    METER
-        .u64_histogram(HTTP_CLIENT_REQUEST_DURATION)
-        .with_unit("ms")
-        .with_description("Duration of HTTP client requests")
-        .build()
-});
-
-static HTTP_REQUESTS_IN_FLIGHT: LazyLock<UpDownCounter<i64>> = LazyLock::new(|| {
-    METER
-        .i64_up_down_counter(HTTP_CLIENT_ACTIVE_REQUESTS)
-        .with_unit("{requests}")
-        .with_description("Number of HTTP client requests in flight")
-        .build()
-});
-
-struct TracingResolver {
-    inner: GaiResolver,
-}
-
-impl TracingResolver {
-    fn new() -> Self {
-        let inner = GaiResolver::new();
-        Self { inner }
-    }
-}
-
-impl reqwest::dns::Resolve for TracingResolver {
-    fn resolve(&self, name: reqwest::dns::Name) -> reqwest::dns::Resolving {
-        let span = tracing::info_span!("dns.resolve", name = name.as_str());
-        let inner = &mut self.inner.clone();
-        Box::pin(
-            inner
-                .call(Name::from_str(name.as_str()).unwrap())
-                .map(|result| {
-                    result
-                        .map(|addrs| -> reqwest::dns::Addrs { Box::new(addrs) })
-                        .map_err(|err| -> BoxError { Box::new(err) })
-                })
-                .instrument(span),
-        )
-    }
-}
+// static HTTP_REQUESTS_DURATION_HISTOGRAM: LazyLock<Histogram<u64>> = LazyLock::new(|| {
+//     METER
+//         .u64_histogram(HTTP_CLIENT_REQUEST_DURATION)
+//         .with_unit("ms")
+//         .with_description("Duration of HTTP client requests")
+//         .build()
+// });
+
+// static HTTP_REQUESTS_IN_FLIGHT: LazyLock<UpDownCounter<i64>> = LazyLock::new(|| {
+//     METER
+//         .i64_up_down_counter(HTTP_CLIENT_ACTIVE_REQUESTS)
+//         .with_unit("{requests}")
+//         .with_description("Number of HTTP client requests in flight")
+//         .build()
+// });
+
+// struct TracingResolver {
+//     inner: GaiResolver,
+// }
+
+// impl TracingResolver {
+//     fn new() -> Self {
+//         let inner = GaiResolver::new();
+//         Self { inner }
+//     }
+// }
+
+// impl reqwest::dns::Resolve for TracingResolver {
+//     fn resolve(&self, name: reqwest::dns::Name) -> reqwest::dns::Resolving {
+//         let span = tracing::info_span!("dns.resolve", name = name.as_str());
+//         let inner = &mut self.inner.clone();
+//         Box::pin(
+//             inner
+//                 .call(Name::from_str(name.as_str()).unwrap())
+//                 .map(|result| {
+//                     result
+//                         .map(|addrs| -> reqwest::dns::Addrs { Box::new(addrs) })
+//                         .map_err(|err| -> BoxError { Box::new(err) })
+//                 })
+//                 .instrument(span),
+//         )
+//     }
+// }
 
 /// Create a new [`reqwest::Client`] with sane parameters
 ///
@@ -92,12 +95,12 @@ impl reqwest::dns::Resolve for TracingResolver {
 pub fn client() -> reqwest::Client {
     // TODO: can/should we limit in-flight requests?
     reqwest::Client::builder()
-        .dns_resolver(Arc::new(TracingResolver::new()))
-        .use_preconfigured_tls(rustls_platform_verifier::tls_config())
+        // .dns_resolver(Arc::new(TracingResolver::new()))
+        // .use_preconfigured_tls(rustls_platform_verifier::tls_config())
         .user_agent(USER_AGENT)
-        .timeout(Duration::from_secs(60))
-        .connect_timeout(Duration::from_secs(30))
-        .read_timeout(Duration::from_secs(30))
+        // .timeout(Duration::from_secs(60))
+        // .connect_timeout(Duration::from_secs(30))
+        // .read_timeout(Duration::from_secs(30))
         .build()
         .expect("failed to create HTTP client")
 }
@@ -113,109 +116,105 @@ async fn send_traced(
     let server_address = request.url().host_str().map(ToOwned::to_owned);
     let server_port = request.url().port_or_known_default();
     let scheme = request.url().scheme().to_owned();
-    let user_agent = headers
-        .typed_get::<UserAgent>()
-        .map(tracing::field::display);
+    let user_agent = headers.typed_get::<UserAgent>();
     let content_length = headers.typed_get().map(|ContentLength(len)| len);
     let method = request.method().to_string();
 
-    // Create a new span for the request
-    let span = tracing::info_span!(
-        "http.client.request",
-        "otel.kind" = "client",
-        "otel.status_code" = tracing::field::Empty,
-        { HTTP_REQUEST_METHOD } = method,
-        { URL_FULL } = %request.url(),
-        { HTTP_RESPONSE_STATUS_CODE } = tracing::field::Empty,
-        { SERVER_ADDRESS } = server_address,
-        { SERVER_PORT } = server_port,
-        { HTTP_REQUEST_BODY_SIZE } = content_length,
-        { HTTP_RESPONSE_BODY_SIZE } = tracing::field::Empty,
-        { NETWORK_TRANSPORT } = "tcp",
-        { NETWORK_TYPE } = tracing::field::Empty,
-        { NETWORK_LOCAL_ADDRESS } = tracing::field::Empty,
-        { NETWORK_LOCAL_PORT } = tracing::field::Empty,
-        { NETWORK_PEER_ADDRESS } = tracing::field::Empty,
-        { NETWORK_PEER_PORT } = tracing::field::Empty,
-        { USER_AGENT_ORIGINAL } = user_agent,
-        "rust.error" = tracing::field::Empty,
-    );
+    // // Create a new span for the request
+    // let span = tracing::info_span!(
+    //     "http.client.request",
+    //     "otel.kind" = "client",
+    //     "otel.status_code" = tracing::field::Empty,
+    //     { HTTP_REQUEST_METHOD } = method,
+    //     { URL_FULL } = %request.url(),
+    //     { HTTP_RESPONSE_STATUS_CODE } = tracing::field::Empty,
+    //     { SERVER_ADDRESS } = server_address,
+    //     { SERVER_PORT } = server_port,
+    //     { HTTP_REQUEST_BODY_SIZE } = content_length,
+    //     { HTTP_RESPONSE_BODY_SIZE } = tracing::field::Empty,
+    //     { NETWORK_TRANSPORT } = "tcp",
+    //     { NETWORK_TYPE } = tracing::field::Empty,
+    //     { NETWORK_LOCAL_ADDRESS } = tracing::field::Empty,
+    //     { NETWORK_LOCAL_PORT } = tracing::field::Empty,
+    //     { NETWORK_PEER_ADDRESS } = tracing::field::Empty,
+    //     { NETWORK_PEER_PORT } = tracing::field::Empty,
+    //     { USER_AGENT_ORIGINAL } = user_agent,
+    //     "rust.error" = tracing::field::Empty,
+    // );
 
     // Inject the span context into the request headers
-    let context = span.context();
-    opentelemetry::global::get_text_map_propagator(|propagator| {
-        let mut injector = HeaderInjector(request.headers_mut());
-        propagator.inject_context(&context, &mut injector);
-    });
-
-    let mut metrics_labels = vec![
-        KeyValue::new(HTTP_REQUEST_METHOD, method.clone()),
-        KeyValue::new(URL_SCHEME, scheme),
-    ];
-
-    if let Some(server_address) = server_address {
-        metrics_labels.push(KeyValue::new(SERVER_ADDRESS, server_address));
-    }
+    // let context = span.context();
+    // opentelemetry::global::get_text_map_propagator(|propagator| {
+    //     let mut injector = HeaderInjector(request.headers_mut());
+    //     propagator.inject_context(&context, &mut injector);
+    // });
 
-    if let Some(server_port) = server_port {
-        metrics_labels.push(KeyValue::new(SERVER_PORT, i64::from(server_port)));
-    }
+    // let mut metrics_labels =
+    //     vec![KeyValue::new(HTTP_REQUEST_METHOD, method.clone()), KeyValue::new(URL_SCHEME, scheme)];
+
+    // if let Some(server_address) = server_address {
+    //     metrics_labels.push(KeyValue::new(SERVER_ADDRESS, server_address));
+    // }
+
+    // if let Some(server_port) = server_port {
+    //     metrics_labels.push(KeyValue::new(SERVER_PORT, i64::from(server_port)));
+    // }
 
-    HTTP_REQUESTS_IN_FLIGHT.add(1, &metrics_labels);
+    // HTTP_REQUESTS_IN_FLIGHT.add(1, &metrics_labels);
     async move {
-        let span = tracing::Span::current();
+        // let span = tracing::Span::current();
         let result = client.execute(request).await;
 
         // XXX: We *could* loose this if the future is dropped before this, but let's
         // not worry about it for now. Ideally we would use a `Drop` guard to decrement
         // the counter
-        HTTP_REQUESTS_IN_FLIGHT.add(-1, &metrics_labels);
+        // HTTP_REQUESTS_IN_FLIGHT.add(-1, &metrics_labels);
 
         let duration = start.elapsed().as_millis().try_into().unwrap_or(u64::MAX);
         let result = match result {
             Ok(response) => {
-                span.record("otel.status_code", "OK");
-                span.record(HTTP_RESPONSE_STATUS_CODE, response.status().as_u16());
-
-                if let Some(ContentLength(content_length)) = response.headers().typed_get() {
-                    span.record(HTTP_RESPONSE_BODY_SIZE, content_length);
-                }
-
-                if let Some(http_info) = response.extensions().get::<HttpInfo>() {
-                    let local = http_info.local_addr();
-                    let peer = http_info.remote_addr();
-                    let family = if local.is_ipv4() { "ipv4" } else { "ipv6" };
-                    span.record(NETWORK_TYPE, family);
-                    span.record(NETWORK_LOCAL_ADDRESS, local.ip().to_string());
-                    span.record(NETWORK_LOCAL_PORT, local.port());
-                    span.record(NETWORK_PEER_ADDRESS, peer.ip().to_string());
-                    span.record(NETWORK_PEER_PORT, peer.port());
-                } else {
-                    tracing::warn!("No HttpInfo injected in response extensions");
-                }
-
-                metrics_labels.push(KeyValue::new(
-                    HTTP_RESPONSE_STATUS_CODE,
-                    i64::from(response.status().as_u16()),
-                ));
+                // span.record("otel.status_code", "OK");
+                // span.record(HTTP_RESPONSE_STATUS_CODE, response.status().as_u16());
+
+                // if let Some(ContentLength(content_length)) = response.headers().typed_get() {
+                //     span.record(HTTP_RESPONSE_BODY_SIZE, content_length);
+                // }
+
+                // if let Some(http_info) = response.extensions().get::<HttpInfo>() {
+                //     let local = http_info.local_addr();
+                //     let peer = http_info.remote_addr();
+                //     let family = if local.is_ipv4() { "ipv4" } else { "ipv6" };
+                //     span.record(NETWORK_TYPE, family);
+                //     span.record(NETWORK_LOCAL_ADDRESS, local.ip().to_string());
+                //     span.record(NETWORK_LOCAL_PORT, local.port());
+                //     span.record(NETWORK_PEER_ADDRESS, peer.ip().to_string());
+                //     span.record(NETWORK_PEER_PORT, peer.port());
+                // } else {
+                //     tracing::warn!("No HttpInfo injected in response extensions");
+                // }
+
+                // metrics_labels.push(KeyValue::new(
+                //     HTTP_RESPONSE_STATUS_CODE,
+                //     i64::from(response.status().as_u16()),
+                // ));
 
                 Ok(response)
             }
             Err(err) => {
-                span.record("otel.status_code", "ERROR");
-                span.record("rust.error", &err as &dyn std::error::Error);
+                // span.record("otel.status_code", "ERROR");
+                // span.record("rust.error", &err as &dyn std::error::Error);
 
-                metrics_labels.push(KeyValue::new(ERROR_TYPE, "NO_RESPONSE"));
+                // metrics_labels.push(KeyValue::new(ERROR_TYPE, "NO_RESPONSE"));
 
                 Err(err)
             }
         };
 
-        HTTP_REQUESTS_DURATION_HISTOGRAM.record(duration, &metrics_labels);
+        // HTTP_REQUESTS_DURATION_HISTOGRAM.record(duration, &metrics_labels);
 
         result
     }
-    .instrument(span)
+    // .instrument(span)
     .await
 }
 
